EmptyHeaded Query Compiler
----------------------------

Table of Contents
-----------------

  * [Usage](#usage)
  * [Overview](#overview)
  * [Query Plans](#query-plans)

Overview
------------

A call to `Emptyheaded.query` kicks off a run of the query compiler, which receives the string passed to `Emptyheaded.query` and generates a query plan for it by finding min FHW generalized hypertree decompositions (GHDs) and then using various heuristics to pick one of these GHDs. Based on this query plan, it then generates C++ that can be compiled to execute the query.  

Usage
--------

The query compiler is normally run through the ipython notebook, but it can also be run from the command line. You can build the jar by running `sbt pack` from the query_compiler directory. You can then run the query compiler by running:

```
./target/pack/bin/query-compiler -c example_config/config.json -q "Triangle\(a,b,c\):-Edge\(a,b\),Edge\(b,c\),Edge\(a,c\)\."
```
This would run the query compiler with the specified config (note that this is normally generated by a call of `EmptyHeaded.createDB`), on the triangle query. You can find the generated C++ in `Emptyheaded/storage_engine/codegen/Query.cpp`. If you run with the `--explain` option, the compiler will write the query plan to stdout (no codegen).

There are several other options, including an option for running codegen from a user-specified json query plan (useful if you have a query plan you want to try that our query planner doesn't produce). You can get a more complete explanation of all the options by running with `--help`.

Query Plans
----------------
The fields in the query plans are fairly extensively documented in [`src/main/scala/QueryPlan.scala`](https://github.com/HazyResearch/EmptyHeaded/blob/qc_documentation/query_compiler/src/main/scala/QueryPlan.scala).
